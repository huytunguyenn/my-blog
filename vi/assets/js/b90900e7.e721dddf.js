"use strict";(self.webpackChunktu_website=self.webpackChunktu_website||[]).push([[6570],{7565:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var s=t(5893),o=t(1151);const r={sidebar_label:"concurrency & async"},a="Concurrency & Async Patterns",i={id:"learn/framework/nodejs/concurrency",title:"Concurrency & Async Patterns",description:"Foundation",source:"@site/docs/learn/framework/nodejs/6-concurrency.mdx",sourceDirName:"learn/framework/nodejs",slug:"/learn/framework/nodejs/concurrency",permalink:"/my-blog/vi/docs/learn/framework/nodejs/concurrency",draft:!1,unlisted:!1,editUrl:"https://github.com/huytunguyenn/my-blog/tree/main/docs/learn/framework/nodejs/6-concurrency.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_label:"concurrency & async"},sidebar:"docs",previous:{title:"modules",permalink:"/my-blog/vi/docs/learn/framework/nodejs/modules"},next:{title:"web servers",permalink:"/my-blog/vi/docs/learn/framework/nodejs/web-servers"}},l={},c=[{value:"Foundation",id:"foundation",level:2},{value:"Callbacks",id:"callbacks",level:3},{value:"Event Loop",id:"event-loop",level:3},{value:"Promises",id:"promises",level:3},{value:"Generators",id:"generators",level:3},{value:"<code>async</code> / <code>await</code>",id:"async--await",level:3},{value:"Async Patterns",id:"async-patterns",level:2},{value:"Event-driven",id:"event-driven",level:2},{value:"Event Emitters",id:"event-emitters",level:3},{value:"Worker Threads",id:"worker-threads",level:2}];function d(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",math:"math",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"concurrency--async-patterns",children:"Concurrency & Async Patterns"}),"\n",(0,s.jsx)(n.h2,{id:"foundation",children:"Foundation"}),"\n",(0,s.jsx)(n.h3,{id:"callbacks",children:"Callbacks"}),"\n",(0,s.jsx)(n.p,{children:'A function that Node will "call back" at a later point in the time of program.'}),"\n",(0,s.jsx)(n.p,{children:"Callbacks help us to write code in a asynchronous way. While the actual thing does the asynchronous works is Node (C++ behind the scene)."}),"\n",(0,s.jsx)(n.h3,{id:"event-loop",children:"Event Loop"}),"\n",(0,s.jsxs)(n.p,{children:["See more ",(0,s.jsx)(n.a,{href:"/my-blog/vi/docs/learn/framework/nodejs/characteristics#event-loop",children:"example"}),"."]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"Node uses this to process asynchronous actions and interface them for you so that you don't have to deal with threads."}),(0,s.jsx)(n.p,{children:"In other languages, you have to manage threads yourself, start them, do async works inside of them, monitor them, make sure they don't access shared data (or they do but make sure no race conditions)."})]}),"\n",(0,s.jsxs)(n.p,{children:["Infinite loop built inside Node. The event loop ",(0,s.jsx)(n.strong,{children:"synchronously"})," executes task in the synchronous task queue (also called ",(0,s.jsx)(n.strong,{children:"call stack"}),"), because JavaScript is single-threaded, so ",(0,s.jsx)(n.strong,{children:'event loop is "single-threaded"'}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"event loop",src:t(7965).Z+"",width:"1508",height:"553"})}),"\n",(0,s.jsx)(n.p,{children:"However, since only one thing can execute at a time, long running tasks will block others. So the Node runtime & web browser minimize this by allowing use to execute code asynchronously."}),"\n",(0,s.jsxs)(n.p,{children:["It adds task to async task queue (",(0,s.jsx)(n.strong,{children:"async tasks are callback functions"}),"), when event loop executes all items in sync task queue, it will look for tasks in async task queue to execute."]}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Q"}),": If JavaScript is single-threaded, where are these asynchronous tasks running while the event loop executes other parts?"]}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"A"}),": The only part that's limited to single thread is your JavaScript code! For example, when you read file with ",(0,s.jsx)(n.code,{children:"fs"}),", under the hood, it's actually calling into code written in C++ that can use multiple threads to perform the work (C++ code b\u1ecf callback v\xe0o async queue nh\u01b0 h\xecnh tr\xean)."]})]}),"\n",(0,s.jsx)(n.p,{children:"To stop it, you can use Linux kill command with process ID or Ctrl + C."}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"Don't block event loop."}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"The code we write runs in a single thread."})})," Therefore, to keep the app responsive, we need to keep the event loop looping and picking up new code to execute."]}),(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mo,{children:"\u2192"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\rightarrow"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"\u2192"})]})})]})," ",(0,s.jsx)(n.strong,{children:"write asynchronous code"})]})]}),"\n",(0,s.jsx)(n.h3,{id:"promises",children:"Promises"}),"\n",(0,s.jsxs)(n.p,{children:["A mystery thing that someone promises to give you. It might turn into thing you asked for eventually (success), or not (failure) ",":D"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// creating\nfunction doAsyncWork(resolve, reject) {\n  // perform async calls\n  if (success) {\n    resolve(data)\n  } else {\n    reject(reason)\n  }\n}\nlet myPromise = new Promise(doAsyncWork);\n\n// calling\nmyPromise()\n  .then(data => console.log(data))\n  .catch(error => console.error(error))\n  .finally(() => console.log('All done'))\n"})}),"\n",(0,s.jsx)(n.h3,{id:"generators",children:"Generators"}),"\n",(0,s.jsx)(n.p,{children:"Specail type of function that can be paused in the middle of execution and resumed at some point in the future:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"it stores the state of the function while paused"}),"\n",(0,s.jsxs)(n.li,{children:["return ",(0,s.jsx)(n.em,{children:"generator"})," objects (which is iterators)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["They employ a technique known as ",(0,s.jsx)(n.strong,{children:"lazy execution"}),", means values only computed on demand, not doing any unnecessary work. They enable the functionality we get with ",(0,s.jsx)(n.code,{children:"async"})," and ",(0,s.jsx)(n.code,{children:"await"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function *generatorFunction() {\n  console.log('starts')\n  let x = 5\n  yield x  // resume here & return x\n\n  x++\n  y = yield x  // value assigned to y is whatever pass to the next() to resume execution\n  return x + y\n}\nlet iterator = generatorFunction()\nconsole.log(iterator.next())  // prints 'starts', { value: 5, done: false }\nconsole.log(iterator.next())  // { value: 6, done: false }\nconsole.log(iterator.next(4))  // { value: 10, done: true }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"async--await",children:[(0,s.jsx)(n.code,{children:"async"})," / ",(0,s.jsx)(n.code,{children:"await"})]}),"\n",(0,s.jsxs)(n.p,{children:["They're built on top of promises and generators. ",(0,s.jsx)(n.code,{children:"async"})," marks functions that can be paused while it ",(0,s.jsx)(n.code,{children:"awaits"})," the resolution of a promise:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"data returned from async functions is automatically wrapped in a promise."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"await"})," can only be added in front of function that returns a promise:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"it pauses the current async function while it waits for the promise to be resolved"}),"\n",(0,s.jsx)(n.li,{children:"it also unwraps the data in the resolved promise for us"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["It helps you ",(0,s.jsx)(n.strong,{children:"write asynchronous code that reads more like synchronous code"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// this looks like synchronous\nconst func = async () => {\n  const data = await getData();\n  return data;\n}\n\n// but it's actually asynchronous\nfunc.then(data => console.log(data))\nconsole.log('END')\n\n// highlight-start\n// console\n> END\n> data ...\n// highlight-end\n"})}),"\n",(0,s.jsx)(n.h2,{id:"async-patterns",children:"Async Patterns"}),"\n",(0,s.jsx)(n.p,{children:"Node originally used the callback pattern for everything asynchronous. Nowadays, it adopts more patterns, as they surface in the JavaScript itself."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// synchronous\nconst data = fs.readFileSync(__filename);\nconsole.log(data)  // prints first\nconsole.log('HERE')  // prints last\n\n// asynchronous\n/**\n* this method is asynchronous, it goes through the event loop\n* we can't access the data directly after calling this method\n* -> Node use callback pattern here\n*/\nfs.readFile(__filename, function cb(err, data) {\n  console.log(data)\n})\nconsole.log('HERE') // prints first, because the readFile is async, no blocking\n\n// promise\nconst readFile = util.promisify(fs.readFile);\nasync function main() {\n  const data = await readFile(__filename)\n  console.log(data)\n}\nmain()\nconsole.log('HERE')\n"})}),"\n",(0,s.jsx)(n.h2,{id:"event-driven",children:"Event-driven"}),"\n",(0,s.jsx)(n.p,{children:"Event-driven programming is a style of programming in which the flow of program is at least in part determined by the events that occur as the program executes."}),"\n",(0,s.jsx)(n.h3,{id:"event-emitters",children:"Event Emitters"}),"\n",(0,s.jsxs)(n.p,{children:["A class help you to instantiate an event emitter and then define mutilple callbacks to be invoked when a particular event is emitted: ",(0,s.jsx)(n.code,{children:"emitter.emit()"}),", ",(0,s.jsx)(n.code,{children:"emitter.on()"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const EventEmitter = require('events')\n\nconst emitter = new EventEmitter()\n// you have to register before emit\n// listen to event\nemitter.on('SOME_EVENT', (msg) => { console.log(msg) })\n// at some point we emit event\nemitter.emit('SOME_EVENT', 'Hello World!')  // prints Hello World!\n\nsetImmediate(() => { ... }) // push the execution of the code into the next cycle of the event loop\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"EventEmiiter"})," calls all listerners synchronously in the order in which they were registered."]}),"\n",(0,s.jsxs)(n.p,{children:["Below is not a recommended way to code, but at least you know it exists, there are other HOCs build on the ",(0,s.jsx)(n.code,{children:"EventEmitters"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const serveCustomer = (customer, done) => {\n  // what to do when customer decide\n  customer.on('decided', order => {\n    order.on('prepared', food => customer.eatAndPay(food))\n    cook.prepareFood(order)\n  })\n  // what to do when customer leave\n  customer.on('leaving', tip => done(null, tip))\n\n  // after all the callbacks are registered, we give menu to customer\n  customer.placeOrder(menu)\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"worker-threads",children:"Worker Threads"}),"\n",(0,s.jsx)(n.p,{children:"The Node event loop is great at letting you asynchronously offload I/O operations, but the single-threaded nature means no good to deal with long running CPU-intensive tasks."}),"\n",(0,s.jsx)(n.p,{children:"Worker threads give you APIs to deal with CPU-intensive tasks, it send those types of workloads to another thread while keeping main thread available for a new user request."}),"\n",(0,s.jsx)(n.p,{children:"Each worker thread instance is really a new instance of the event loop."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["We don't have some tradition mechanisms for ",(0,s.jsx)(n.strong,{children:"thread synchronization"}),", but we can pass messages back and forth between main thread and worker thread"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const { Worker, isMainThread } = require('worker_threads')\n\nif (isMainThread) {\n  const firstWorker = new Worker(__filename)\n} else {\n  const secondWorker = new Worker('cpu_intensive.js')\n  const thirdWorker = new Worker(`\n    console.log('Do CPU-intensive stuff here')\n  `, { eval: true })\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"More example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const { Worker, isMainThread, parentPort, workerData } = require('worker_threads')\n\nif(isMainThread) {\n  console.log('Starting the main thread')\n  const worker = new Worker(__filename, {\n    workerData: {\n      prefix: 'Received message',\n      delay: 2000\n    }\n  })\n  // register event handlers for worker thread\n  worker.on('message', (msg) => { console.log(`Worker: ${msg}`) })\n  worker.postMessage('Done with my work')\n  console.log('Still in the main thread')\n\n} else {\n  // this only registers, doesn't mean it will run first\n  parentPort.on('message', (msg) => { console.log(`${workerData.prefix}: ${msg}`) })\n\n  parentPort.postMessage('Getting started')  // parentPort is communication port back to the main thread\n  wasteTime(workerData.delay)  // block the worker thread\n  parentPort.postMessage('In the middle')  // it's also an EventEmitter, `message` event\n  wasteTime(workerData.delay)\n  parentPort.postMessage('All done')\n}\n\nfunction wasteTime(delay) {\n  const end = Date.now() + delay\n  while(Date.now() < end) { }\n}\n\n// highlight-start\n> Starting the main thread\n> Still in the main thread\n> Worker: Getting started\n> Worker: In the middle\n> Worker: All done\n> Received message: Done with my work  // worker event loop is still being blocked by wasteTime call\n// highlight-end\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"This should only be used for CPU-intensive tasks. For I/O bound code, like disk access and network calls, it's more efficient to use the asynchronous APIs."})})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},7965:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/callstack-2c10d01c901146fdf80d0667ba1b3e48.png"},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>a});var s=t(7294);const o={},r=s.createContext(o);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);