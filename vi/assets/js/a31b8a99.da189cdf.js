"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[623],{3905:(e,a,t)=>{t.d(a,{Zo:()=>m,kt:()=>d});var n=t(7294);function s(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function r(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){s(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,s=function(e,a){if(null==e)return{};var t,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(s[t]=e[t]);return s}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var o=n.createContext({}),p=function(e){var a=n.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):r(r({},a),e)),t},m=function(e){var a=p(e.components);return n.createElement(o.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},u=n.forwardRef((function(e,a){var t=e.components,s=e.mdxType,i=e.originalType,o=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(t),d=s,h=u["".concat(o,".").concat(d)]||u[d]||c[d]||i;return t?n.createElement(h,r(r({ref:a},m),{},{components:t})):n.createElement(h,r({ref:a},m))}));function d(e,a){var t=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var i=t.length,r=new Array(i);r[0]=u;var l={};for(var o in a)hasOwnProperty.call(a,o)&&(l[o]=a[o]);l.originalType=e,l.mdxType="string"==typeof e?e:s,r[1]=l;for(var p=2;p<i;p++)r[p]=t[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,t)}u.displayName="MDXCreateElement"},6063:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var n=t(7462),s=(t(7294),t(3905));const i={sidebar_label:"oop",description:"object-oriented programming with Java features & examples",toc_max_heading_level:4},r="Object-oriented Programming",l={unversionedId:"learn/language/java/oop",id:"learn/language/java/oop",title:"Object-oriented Programming",description:"object-oriented programming with Java features & examples",source:"@site/docs/learn/language/java/10-oop.mdx",sourceDirName:"learn/language/java",slug:"/learn/language/java/oop",permalink:"/my-blog/vi/docs/learn/language/java/oop",draft:!1,editUrl:"https://github.com/huytunguyenn/my-blog/tree/main/docs/learn/language/java/10-oop.mdx",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_label:"oop",description:"object-oriented programming with Java features & examples",toc_max_heading_level:4},sidebar:"docs",previous:{title:"classes & objects",permalink:"/my-blog/vi/docs/learn/language/java/classes-and-objects"},next:{title:"wrapper",permalink:"/my-blog/vi/docs/learn/language/java/wrapper-classes"}},o={},p=[{value:"Abstraction",id:"abstraction",level:2},{value:"Encapsulation",id:"encapsulation",level:2},{value:"Field Accessors &amp; Mutators",id:"field-accessors--mutators",level:3},{value:"Inheritance",id:"inheritance",level:2},{value:"A Summary",id:"a-summary",level:4},{value:"Subclassing",id:"subclassing",level:3},{value:"Superclass",id:"superclass",level:3},{value:"Overriding",id:"overriding",level:3},{value:"Prevent Overriding",id:"prevent-overriding",level:3},{value:"Sealed Classes",id:"sealed-classes",level:3},{value:"Polymorphism",id:"polymorphism",level:2},{value:"A Summary",id:"a-summary-1",level:4},{value:"Is-A Relationship",id:"is-a-relationship",level:3},{value:"Upcasting",id:"upcasting",level:3},{value:"Downcasting / <code>instanceof</code>",id:"downcasting--instanceof",level:3},{value:"Polymorphism by Inheritance",id:"polymorphism-by-inheritance",level:3},{value:"An example",id:"an-example",level:4},{value:"Abstract Classes",id:"abstract-classes",level:3},{value:"Interfaces",id:"interfaces",level:3},{value:"Limitations",id:"limitations",level:4},{value:"Best Practices",id:"best-practices",level:2},{value:"SOLID principles",id:"solid-principles",level:2},{value:"Single Responsibility",id:"single-responsibility",level:3},{value:"Open-closed",id:"open-closed",level:3},{value:"Liskov Substitution",id:"liskov-substitution",level:3},{value:"Interface Segregation",id:"interface-segregation",level:3},{value:"Dependency Inversion",id:"dependency-inversion",level:3},{value:"Design Patterns",id:"design-patterns",level:2}],m={toc:p};function c(e){let{components:a,...t}=e;return(0,s.kt)("wrapper",(0,n.Z)({},m,t,{components:a,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"object-oriented-programming"},"Object-oriented Programming"),(0,s.kt)("p",null,"4 main theoretical principles:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"abstraction, and encapsulation"),(0,s.kt)("li",{parentName:"ul"},"polymorphism, and inheritance")),(0,s.kt)("h2",{id:"abstraction"},"Abstraction"),(0,s.kt)("p",null,"A lot of programming is about ",(0,s.kt)("strong",{parentName:"p"},"types"),". A types can tell you:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"what the variable looks like (e.g. boolean is a simple flag)"),(0,s.kt)("li",{parentName:"ul"},"what you can do with that variable (e.g. you cannot )")),(0,s.kt)("p",null,"Java has had primitives type already, and you can define new type with OOP (type == class). ",(0,s.kt)("strong",{parentName:"p"},"Defining new types")," and ",(0,s.kt)("strong",{parentName:"p"},"creating objects out of them")," is called abstraction."),(0,s.kt)("p",null,"Abstraction can also be achieved by encapsulation (",(0,s.kt)("strong",{parentName:"p"},"hide details"),"), so it ",(0,s.kt)("strong",{parentName:"p"},"only shows interfaces"),". See ",(0,s.kt)("a",{parentName:"p",href:"#field-accessors--mutators"},"below"),"."),(0,s.kt)("admonition",{title:"a wise man once said",type:"note"},(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("em",{parentName:"p"},"Abstraction can be thought of as a natural extension of encapsulation."))),(0,s.kt)("h2",{id:"encapsulation"},"Encapsulation"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Hiding information")," inside the class is called encapsulation. It helps classes:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"easier to use: only care about interface, not the implementation"),(0,s.kt)("li",{parentName:"ul"},"harder to misuse: protect object from inconsistent changes"),(0,s.kt)("li",{parentName:"ul"},"easier to change: change the implementation without breaking clients")),(0,s.kt)("h3",{id:"field-accessors--mutators"},"Field Accessors & Mutators"),(0,s.kt)("p",null,"You can hide information of class using ",(0,s.kt)("a",{parentName:"p",href:"/my-blog/vi/docs/learn/language/java/classes-and-objects#access-modifier"},"Access Modifier"),"."),(0,s.kt)("p",null,"By making some members private, we split fields & methods into 2 groups:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"interface"),": public members, means it's visible from the outside to use"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"implementation"),": private members, contains internal details, we can easily change implementation without affect interface")),(0,s.kt)("p",null,"Usually, we want to make fields private (so it cannot be normally directly accessed). But sometimes, we need to expose that (when encapsulation meets ",(0,s.kt)("a",{parentName:"p",href:"#inheritance"},"inheritance"),")"),(0,s.kt)("p",null,(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mo",{parentName:"mrow"},"\u2192")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\rightarrow")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.3669em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"\u2192")))))," public/protected ",(0,s.kt)("strong",{parentName:"p"},"getters & setters")," for private fields"),(0,s.kt)("h2",{id:"inheritance"},"Inheritance"),(0,s.kt)("p",null,"Copy & paste code is a bad idea ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mo",{parentName:"mrow"},"\u2192")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\rightarrow")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.3669em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"\u2192")))))," we should reuse the common logic and extract the unique logic into a separate class"),(0,s.kt)("p",null,(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mo",{parentName:"mrow"},"\u2192")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\rightarrow")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.3669em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"\u2192")))))," make some classes ",(0,s.kt)("em",{parentName:"p"},"inherits")," another class"),(0,s.kt)("h4",{id:"a-summary"},"A Summary"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Inheritance is (mostly) when you want to ",(0,s.kt)("a",{parentName:"li",href:"#upcasting"},"upcasting"),"."),(0,s.kt)("li",{parentName:"ul"},"Inheritance can be used to share code, but there are other better ways to do that (e.g. include a new field type in class a.k.a ",(0,s.kt)("strong",{parentName:"li"},"delegation"),").")),(0,s.kt)("h3",{id:"subclassing"},"Subclassing"),(0,s.kt)("p",null,"Use ",(0,s.kt)("inlineCode",{parentName:"p"},"extends"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"public class Student extends Person {\n  private final int age;\n  public Student(int age) { this.age = age; }\n  public int getAge() { return age; }\n}\n")),(0,s.kt)("admonition",{type:"info"},(0,s.kt)("p",{parentName:"admonition"},"Every class in Java inherits ",(0,s.kt)("inlineCode",{parentName:"p"},"Object")," class.")),(0,s.kt)("h3",{id:"superclass"},"Superclass"),(0,s.kt)("p",null,"Constructor is meant to guarantee that objects are initialized correctly."),(0,s.kt)("p",null,(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mo",{parentName:"mrow"},"\u2192")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\rightarrow")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.3669em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"\u2192")))))," we have to call superclass constructor. Use ",(0,s.kt)("inlineCode",{parentName:"p"},"super()")," to call the superclass constructor."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"public class Student extends Person {\n  public Student(string name, int age) {\n    // -highlight\n    super(name);  // this must come first\n    this.age = age;\n  }\n}\n")),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"If the superclass constructor is default constructor (the constructor with no parameter), Java can automatically call it for us.")),(0,s.kt)("h3",{id:"overriding"},"Overriding"),(0,s.kt)("p",null,"Override the methods from superclass. The code in subclass could be duplicated as well. To avoid that we can call method of superclass using ",(0,s.kt)("inlineCode",{parentName:"p"},"super"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},'class Person {\n  public String getAge(boolean uppercase) {\n    if (isAlive()) {\n      if (uppercase)\n        return this.age.toUpperCase();\n      else\n        return this.age;\n    }\n    return "";\n  }\n}\n\nclass Student {\n  @Override\n  public String getAge(boolean uppercase) {\n    // -error-start\n    // this still duplicates a lot\n    if (isAlive()) {\n      if (uppercase)\n        return "Student age: " + this.age.toUpperCase();\n      else\n        return "Student age: " + this.age;\n    }\n    return "";\n    // -error-end\n    // -highlight-start\n    // call super class instead\n    String age = super.getAge(uppercase);\n    if (age.isEmpty())\n      return "Student age: " + age;\n    else\n      return "Student age: " + age;\n    // -highlight-end\n  }\n}\n')),(0,s.kt)("h3",{id:"prevent-overriding"},"Prevent Overriding"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"final")," can be used with methods or classes. If a method is declared with ",(0,s.kt)("inlineCode",{parentName:"p"},"final"),", it means the method cannot be overridden in a subclass. The same with ",(0,s.kt)("inlineCode",{parentName:"p"},"final")," class, it cannot be inherited."),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Q: The question is why would you want to ",(0,s.kt)("inlineCode",{parentName:"em"},"final")," a method?")," ",(0,s.kt)("strong",{parentName:"p"},"A:")," To prevent bugs, looks at below example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"class Parent {\n  Parent() {\n    someInitMethod();\n  }\n  protected void someInitMethod() {\n    // do esstential initializations\n  }\n}\nclass Child extends Parent {\n  /**\n   * subclass can refine someInitMethod() and cause bug\n   * if that method is private then it's okay (but here, it's protected)\n  **/\n}\n")),(0,s.kt)("p",null,"A good safety rule is if ",(0,s.kt)("strong",{parentName:"p"},"methods called by constructor should be either ",(0,s.kt)("inlineCode",{parentName:"strong"},"private")," or ",(0,s.kt)("inlineCode",{parentName:"strong"},"final")),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"class Parent {\n  // -highlight\n  protected final void someInitMethod() { }\n}\n")),(0,s.kt)("admonition",{type:"caution"},(0,s.kt)("p",{parentName:"admonition"},"Don't overuse ",(0,s.kt)("inlineCode",{parentName:"p"},"final"),". The best way to use it is when you know what to do and prevent bugs.")),(0,s.kt)("h3",{id:"sealed-classes"},"Sealed Classes"),(0,s.kt)("p",null,"In Java 17. It can decide exactly which other classes inherit from it. All sealed class subclasses must either be ",(0,s.kt)("inlineCode",{parentName:"p"},"final"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"sealed")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"non-sealed"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"public sealed class Person permits Student, Worker { }\n\n// subclass can be sealed (means it permitteed subclasses)\npublic sealed class Worker extends Person permits FullTimeWorker { }\n// or non-sealed (means it's just a regular class that you can inherit from)\npublic non-sealed class Student { }\n// or final\npublic final class Student extends Person { }\n\npublic non-sealed class FullTimeWorker extends Worker { }\n")),(0,s.kt)("admonition",{type:"caution"},(0,s.kt)("p",{parentName:"admonition"},"Don't overuse ",(0,s.kt)("inlineCode",{parentName:"p"},"sealed")," classes either.")),(0,s.kt)("h2",{id:"polymorphism"},"Polymorphism"),(0,s.kt)("admonition",{title:"not so funny story",type:"note"},(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("em",{parentName:"p"},"Polymorphism means \u201cmany shapes\u201d in Greek."))),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Read the below subsections first to understand polymorphism.")),(0,s.kt)("h4",{id:"a-summary-1"},"A Summary"),(0,s.kt)("p",null,"The reason why we do polymorphism & inheritance is to just about upcasting."),(0,s.kt)("p",null,"We design the hierarchy just to some point in the code, we can take object of subclass and cast it to a superclass (",(0,s.kt)("a",{parentName:"p",href:"#upcasting"},"upcasting"),")."),(0,s.kt)("p",null,"Why we would want to upcast? Because we wrote the code that ",(0,s.kt)("strong",{parentName:"p"},"talks to the superclass/interface")," to make it easier of extension & maintenance, like this ",(0,s.kt)("a",{parentName:"p",href:"#an-example"},"example"),"."),(0,s.kt)("h3",{id:"is-a-relationship"},"Is-A Relationship"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"Object <|---- Animal <|---- Cat <---- Cat butter = new Cat();\n")),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Example: ",(0,s.kt)("inlineCode",{parentName:"em"},"butter")," is a special case of Cat and also a special case of Animal, and Object as well. The class inheritance is also described as the ",(0,s.kt)("inlineCode",{parentName:"em"},"is-a")," relationship.")),(0,s.kt)("p",null,"Subclass can add stuff to superclass, maybe tweak it, but it ",(0,s.kt)("strong",{parentName:"p"},"cannot take things away from superclass"),'. That would violate this notion that "subclass ',(0,s.kt)("inlineCode",{parentName:"p"},"is-a"),' special case".'),(0,s.kt)("h3",{id:"upcasting"},"Upcasting"),(0,s.kt)("p",null,"Java creates object in the heap and return a reference. We usually take that reference and assign it to a variable, and we cannot assign to a different type variable. But we can assign to a superclass variable."),(0,s.kt)("p",null,"Casting means a type conversion. Upcasting is putting a ",(0,s.kt)("strong",{parentName:"p"},"reference")," into a variable whose type is a superclass of that reference ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("em",{parentName:"strong"},"(we're not changing the object from one type to another, we only effect on reference)")),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},'Student student = new Student();\n// -highlight\nPerson person = student;  // upcasting: cast this upper\nObject greetings = "Hello, world!";  // string is a subclass of Object\n')),(0,s.kt)("p",null,"When upcasting, you lose the specific functionality, in other words, you ",(0,s.kt)("strong",{parentName:"p"},"forget specific subclass"),". Sounds like bad things, but it turns out the cool things in Java for ",(0,s.kt)("a",{parentName:"p",href:"#polymorphism"},"polymorphism"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"// -error\nperson.goToSchool();  // you can't, this is a Student class method\n")),(0,s.kt)("h3",{id:"downcasting--instanceof"},"Downcasting / ",(0,s.kt)("inlineCode",{parentName:"h3"},"instanceof")),(0,s.kt)("p",null,"Java cannot do downcasting automatically because it only has ability to forget about specific subclass (",(0,s.kt)("a",{parentName:"p",href:"#upcasting"},"upcasting"),"). We downcast by converting reference."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"Person person = new Student();\nStudent student = (Student)person;  // down cast Person type -> Student type\nstudent.goToSchool();  // now you can use Student method\n")),(0,s.kt)("p",null,"What if we change: ",(0,s.kt)("inlineCode",{parentName:"p"},"Person person = new Worker();"),"? then, we'll get ",(0,s.kt)("inlineCode",{parentName:"p"},"NullPointerException")," followed by ",(0,s.kt)("inlineCode",{parentName:"p"},"ClassCastException"),"."),(0,s.kt)("admonition",{type:"caution"},(0,s.kt)("p",{parentName:"admonition"},"Because ClassCastException & NullPointerException, we should:"),(0,s.kt)("ul",{parentName:"admonition"},(0,s.kt)("li",{parentName:"ul"},"use ",(0,s.kt)("inlineCode",{parentName:"li"},"instanceof"),": checking before downcasting"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"avoid downcasting"),": improve design to remove unnecessary type conversion"))),(0,s.kt)("h3",{id:"polymorphism-by-inheritance"},"Polymorphism by Inheritance"),(0,s.kt)("admonition",{title:"a wise man once said",type:"note"},(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("em",{parentName:"p"},"Inheritance and polymorphism work together to make powerful weapons"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},'Person person = new Student("Tu");\nperson.sleep();  // call sleep() of `Student` class, not `Person`\n')),(0,s.kt)("h4",{id:"an-example"},"An example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"class Dashboard {\n  /**\n  * Works with whatever you pass to it\n  * It doesn't know and doesn't care what subclass it's dealing with\n  * It just talks to superclass. It allow we forgot the specific type\n  * -> future-proof, means no matter what new class you add to the hierarchy, code still works\n  **/\n  public void add(Alarm alarm) {\n    tool1.method(alarm.turnOn());\n    tool2.method(alarm.plug());\n    // ...\n  }\n}\n\npublic static void main(String[] args) {\n  Dashboard dashboard = new Dashboard();\n  // the dashboard works with any alarm, it talks with Alarm\n  dashboard.add(new NoisyAlarm(\"zzz\"));\n  dashboard.add(new TimeAlarm(100));\n}\n")),(0,s.kt)("p",null,"There are many examples of polymorphism in the core Java libraries. One of that is the ",(0,s.kt)("inlineCode",{parentName:"p"},"System.out.print()"),", the first ever thing we code when approaching Java."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},'/**\n * System.out.println() take many param type, include Object type\n * Object is the root of every class\n * => println() can print anything\n * It turns out println() call toString() method of the passed-in object\n * -> so we only need to override toString() method\n**/\nclass Student {\n  @Override\n  public String toString() { return "I am student"; }\n}\npublic static void main(String[] args) {\n  Person person = new Student();\n  System.out.println(person);\n  // this make easier of extension of println()\n}\n')),(0,s.kt)("admonition",{type:"info"},(0,s.kt)("p",{parentName:"admonition"},"Not all polymorphism in Java is based on inheritance. Other ways is using ",(0,s.kt)("inlineCode",{parentName:"p"},"abstract class")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"interface"),".")),(0,s.kt)("h3",{id:"abstract-classes"},"Abstract Classes"),(0,s.kt)("p",null,"You cannot create an instance of an abstract class directly. But we can create its subclass and ",(0,s.kt)("a",{parentName:"p",href:"#upcasting"},"upcast")," it."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"public abstract class Person {\n  public abstract void walk(){ }\n}\npublic class Student extends Person {\n  public void walk(){ }\n}\n// main\n// -error-start\nPerson person = new Person();  // cannot create instance of abstract class\nperson.walk();\n// -error-end\nPerson person = new Student();\nperson.walk();\n")),(0,s.kt)("p",null,"A class inherits from abstract class must follow rule:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"if that class wants to be concrete (non-abstract), it must ",(0,s.kt)("strong",{parentName:"li"},"provide an implementation for all its methods")," (including those defined and those that inherits from its superclass)"),(0,s.kt)("li",{parentName:"ul"},"otherwise, if any method is still abstract, then the class itself must be abstract.")),(0,s.kt)("p",null,(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mo",{parentName:"mrow"},"\u2192")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\rightarrow")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.3669em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"\u2192")))))," abstract classes only make sense in context of upcasting for polymorphism"),(0,s.kt)("h3",{id:"interfaces"},"Interfaces"),(0,s.kt)("p",null,"The problem of abstract class is the ",(0,s.kt)("em",{parentName:"p"},"updating the hierarchy"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"Student ----|> Person <|---- Worker\n\n> What if we need more method `exist`, `live`\n> -> create `Entity` and `Creature`\n> But you cannot inherit 2 classes\n\nEntity            Creature\n  \\                 \\\n  Creature          Entity\n    \\                 \\\n    Person            Person\n\n>  Here it is        But how about this?\n")),(0,s.kt)("p",null,"Interface came to resolve ",(0,s.kt)("strong",{parentName:"p"},"one object, multiple roles")," problem. They are like extreme abstract class:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"nearly")," everything in ",(0,s.kt)("inlineCode",{parentName:"li"},"interface")," has to be ",(0,s.kt)("inlineCode",{parentName:"li"},"abstract"),", ",(0,s.kt)("em",{parentName:"li"},"usually"),", interface has ",(0,s.kt)("strong",{parentName:"li"},"no field")),(0,s.kt)("li",{parentName:"ul"},"a class can only narrate from 1 superclass ",(0,s.kt)("em",{parentName:"li"},"(except class ",(0,s.kt)("inlineCode",{parentName:"em"},"Object"),")"),", but it can implement all the interfaces at once")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"public interface Entity {\n  public abstract void exist();\n  void exist();  // or we don't need to specify (they are abstract by default)\n}\n\npublic class Student extends Person implements Entity, Creature {\n  // implements all the methods\n  @Override\n  public void exist() { }\n}\n// if this is abstract class then no need to implement\npublic abstract class Person implements Entity, Creature {\n  // this class is abstract, duh!\n}\n")),(0,s.kt)("h4",{id:"limitations"},"Limitations"),(0,s.kt)("p",null,"The point of interfaces exist because Java doesn't want to give you multiple inheritance* (it creates confusing edge cases, horrible hierarchy)."),(0,s.kt)("p",null,"There are some limitations of interfaces:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"interface cannot inherit from a class (it can inherit an interface)"),(0,s.kt)("li",{parentName:"ul"},"no constructor in interface"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"fields")," need to be ",(0,s.kt)("inlineCode",{parentName:"li"},"public static final"),", in other words, ",(0,s.kt)("strong",{parentName:"li"},"global constant")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"methods")," need to be ",(0,s.kt)("inlineCode",{parentName:"li"},"public abstract"),". But there are special cases that methods can be concrete:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"static methods ",(0,s.kt)("em",{parentName:"li"},"(since they have nothing to do with polymorphism)")),(0,s.kt)("li",{parentName:"ul"},"default methods** ",(0,s.kt)("em",{parentName:"li"},"(methods supposed to be abstract, but they came with default implementation)"))),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-java"},"public interface Entity {\n  // we can override this or take the default\n  default boolean doSomething() { return true; }\n}\n")),"(","*",")(","*","*",")",(0,s.kt)("em",{parentName:"li"}," We don't have multiple inheritances, so we cannot put code in an interface, except that now we can")," \ud83e\udee0 ",(0,s.kt)("em",{parentName:"li"},"Having default method is make it more convenient by loosening inheritance a bit."))),(0,s.kt)("h2",{id:"best-practices"},"Best Practices"),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"These are just guidelines! Not absolute rules.")),(0,s.kt)("p",null,"Design guidelines:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"More private is better than less private"),(0,s.kt)("li",{parentName:"ul"},"If no need, keep it private ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mo",{parentName:"mrow"},"\u2192")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\rightarrow")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.3669em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"\u2192")))))," keep interfaces small"),(0,s.kt)("li",{parentName:"ul"},"Encapsulated fields are good"),(0,s.kt)("li",{parentName:"ul"},"Make fields private & only write needed setters"),(0,s.kt)("li",{parentName:"ul"},"Final fields are also good"),(0,s.kt)("li",{parentName:"ul"},"Make it final, make them less changeable (no surprises, no bugs). Field contains an immutable object is great (e.g. string)"),(0,s.kt)("li",{parentName:"ul"},"Avoid chains of ",(0,s.kt)("inlineCode",{parentName:"li"},"instanceof")," and downcasts: use polymorphism instead"),(0,s.kt)("li",{parentName:"ul"},"Inheritance vs. Delegation: Inheritance is not always a good way to share code among classes ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mo",{parentName:"mrow"},"\u2192")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\rightarrow")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.3669em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"\u2192")))))," prefer ",(0,s.kt)("strong",{parentName:"li"},"delegation"),", means create a new class/type to handle that for us."),(0,s.kt)("li",{parentName:"ul"},"Don't overuse ",(0,s.kt)("inlineCode",{parentName:"li"},"static"),": it leads to procedural code")),(0,s.kt)("h2",{id:"solid-principles"},"SOLID principles"),(0,s.kt)("h3",{id:"single-responsibility"},"Single Responsibility"),(0,s.kt)("h3",{id:"open-closed"},"Open-closed"),(0,s.kt)("h3",{id:"liskov-substitution"},"Liskov Substitution"),(0,s.kt)("h3",{id:"interface-segregation"},"Interface Segregation"),(0,s.kt)("h3",{id:"dependency-inversion"},"Dependency Inversion"),(0,s.kt)("h2",{id:"design-patterns"},"Design Patterns"))}c.isMDXComponent=!0}}]);