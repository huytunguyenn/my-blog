"use strict";(self.webpackChunktu_website=self.webpackChunktu_website||[]).push([[1667],{9839:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>d});var s=a(5893),r=a(1151);const t={sidebar_label:"advanced",toc_max_heading_level:4},i="Advanced",l={id:"learn/language/java/advanced",title:"Advanced",description:"Annotations",source:"@site/docs/learn/language/java/12-advanced.mdx",sourceDirName:"learn/language/java",slug:"/learn/language/java/advanced",permalink:"/my-blog/docs/learn/language/java/advanced",draft:!1,unlisted:!1,editUrl:"https://github.com/huytunguyenn/my-blog/tree/main/docs/learn/language/java/12-advanced.mdx",tags:[],version:"current",sidebarPosition:12,frontMatter:{sidebar_label:"advanced",toc_max_heading_level:4},sidebar:"docs",previous:{title:"wrapper",permalink:"/my-blog/docs/learn/language/java/wrapper-classes"},next:{title:"libs",permalink:"/my-blog/docs/learn/language/java/libraries"}},c={},d=[{value:"Annotations",id:"annotations",level:2},{value:"Generics",id:"generics",level:2},{value:"Generic Class",id:"generic-class",level:3},{value:"Generic Types",id:"generic-types",level:3},{value:"Type Parameters",id:"type-parameters",level:4},{value:"Type Arguments",id:"type-arguments",level:4},{value:"Generic Methods",id:"generic-methods",level:3},{value:"Bounded Type Parameters",id:"bounded-type-parameters",level:3},{value:"Multiple Type Parameter Bounds",id:"multiple-type-parameter-bounds",level:4},{value:"Raw Types",id:"raw-types",level:3},{value:"Working with Inheritance",id:"working-with-inheritance",level:3},{value:"Wildcards",id:"wildcards",level:3},{value:"Unbounded Wildcard",id:"unbounded-wildcard",level:4},{value:"Upper Bounded Wildcard",id:"upper-bounded-wildcard",level:4},{value:"Lower Bounded Wildcard",id:"lower-bounded-wildcard",level:4},{value:"Usage",id:"usage",level:4},{value:"Problems",id:"problems",level:5},{value:"Type Erasure &amp; Limitations",id:"type-erasure--limitations",level:3},{value:"Heap Pollution",id:"heap-pollution",level:3},{value:"Working with Array",id:"working-with-array",level:3},{value:"Working with varargs",id:"working-with-varargs",level:3},{value:"Lambda Expressions",id:"lambda-expressions",level:2},{value:"Functional Interfaces",id:"functional-interfaces",level:3},{value:"Standard Functional Interfaces",id:"standard-functional-interfaces",level:4},{value:"Lambda Expressions",id:"lambda-expressions-1",level:3},{value:"Capturing Local Variables",id:"capturing-local-variables",level:4},{value:"Method References",id:"method-references",level:3},{value:"Java Reflection",id:"java-reflection",level:2},{value:"Varargs",id:"varargs",level:2},{value:"Heap pollution from parameterized vararg type",id:"heap-pollution-from-parameterized-vararg-type",level:3}];function o(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",math:"math",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"advanced",children:"Advanced"}),"\n",(0,s.jsx)(n.h2,{id:"annotations",children:"Annotations"}),"\n",(0,s.jsx)(n.p,{children:"Annotations are special types that act as metadata:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It has no direct affect on target behavior"}),"\n",(0,s.jsx)(n.li,{children:"Annotation have to interpreted by things like tools (IntelliJ), execution environment (XML and JSON processors), any program"}),"\n",(0,s.jsx)(n.li,{children:"Can be applied to a type or its members"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common Java core platform annotations"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@Override"}),": indicate we override an inherited method"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@Deprecated"}),": indicate which method is no longer used"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@SuppressWarnings"}),": tell compiler to not generate some kind of warnings (e.g. ",(0,s.jsx)(n.code,{children:'@SuppressWarnings("deprecation")'}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Others:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@FunctionalInterface"}),": ",(0,s.jsx)(n.a,{href:"#functional-interfaces",children:"functional interfaces"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@SafeVarargs"}),": ",(0,s.jsx)(n.a,{href:"#varargs",children:"varargs"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"generics",children:"Generics"}),"\n",(0,s.jsxs)(n.p,{children:["Using ",(0,s.jsx)(n.code,{children:"<>"})," (diamond operator)."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"generic type"})," is a type with ",(0,s.jsx)(n.strong,{children:"type parameters"}),", which is instantiated into a ",(0,s.jsx)(n.strong,{children:"parameterized type"})," by supplying ",(0,s.jsx)(n.strong,{children:"type arguments"})," to fill in its type parameters."]})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type Inference:"})," compiler automatically knows the type without us specifying it."]})}),"\n",(0,s.jsx)(n.h3,{id:"generic-class",children:"Generic Class"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public interface TreeNode<T> {\n    // after decalre `TreeNode<T>`, all its members can use `T` as it\'s an actual type\n    T getValue();\n    TreeNode<T> getLeft();\n    TreeNode<T> getRight();\n}\n\npublic class LeafNode<T> implements TreeNode<T> {\n    private final T value;\n\n    public LeafNode(T value) { this.value = value; }\n    @Override public T getValue() { return value; }\n    @Override public TreeNode<T> getLeft() { return null; }\n    @Override public TreeNode<T> getRight() { return null; }\n    @Override public String toString() { return String.format("[%s]", value); }\n}\n\npublic class InnerNode<T> implements TreeNode<T> {\n    private final TreeNode<T> left, right;\n\n    public InnerNode(TreeNode<T> left, TreeNode<T> right) {\n        this.left = left;\n        this.right = right;\n    }\n    @Override public T getValue() { return null; }\n    @Override public TreeNode<T> getLeft() { return left; }\n    @Override public TreeNode<T> getRight() { return right; }\n    @Override public String toString() { return String.format("{%s, %s}", left, right); }\n}\n// main\npublic static void main(String[] args){\n  var three = new LeafNode<Integer>(3);\n  // type inference: compiler can automatically understand as well\n  var five = new LeafNode<>(5);\n  var tree = new InnerNode<>(new LeafNode<>(2), new InnerNode<>(three, five));\n  System.out.println(tree);\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"generic-types",children:"Generic Types"}),"\n",(0,s.jsxs)(n.admonition,{title:"t\xf3m t\u1eaft",type:"note",children:[(0,s.jsx)(n.p,{children:'N\xf4m na l\xe0 v\u1edbi type b\xecnh th\u01b0\u1eddng, m\xecnh g\u1ecdi "instantiate" l\xe0 create (instance of) new object, c\xf2n v\u1edbi generic type, create new instance of object \u0111\u01b0\u1ee3c g\u1ecdi l\xe0 "instantiating generic type into parameterized type"'}),(0,s.jsxs)(n.p,{children:["D\xf9ng to\xe1n t\u1eed diamond ",(0,s.jsx)(n.code,{children:"<>"}),", c\u1ee9 coi n\xf3 gi\u1ed1ng nh\u01b0 ",(0,s.jsx)(n.code,{children:"new"}),", d\xf9ng \u0111\u1ec3 create a new object from a parameterized type"]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"InnerNode"})," is a ",(0,s.jsx)(n.strong,{children:"generic type"}),". Because it has ",(0,s.jsx)(n.strong,{children:"type parameter"})," ",(0,s.jsx)(n.code,{children:"<T>"})," (",(0,s.jsx)(n.code,{children:"public class InnerNode<T> implements TreeNode<T>"}),")."]}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters",children:"Type Parameters"}),"\n",(0,s.jsx)(n.p,{children:"A placeholder for an actual concrete type:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Usually use single capital letter for convention. ",(0,s.jsx)(n.code,{children:"<T>"})," stands for type, ",(0,s.jsx)(n.code,{children:"<K, V>"})," stands for key and value."]}),"\n",(0,s.jsxs)(n.li,{children:["Cannot use ",(0,s.jsx)(n.a,{href:"/my-blog/docs/learn/language/java/data-types#primitive-types",children:"primitive type"})," as type arguments ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mo,{children:"\u2192"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\rightarrow"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"\u2192"})]})})]})," use ",(0,s.jsx)(n.a,{href:"/my-blog/docs/learn/language/java/wrapper-classes",children:"wrapper type"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Cannot use on ",(0,s.jsx)(n.em,{children:"anonymous inner classes, enums and exception classes"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"type-arguments",children:"Type Arguments"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"var three = new LeafNode<Integer>(3);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Integer"})," is ",(0,s.jsx)(n.strong,{children:"type argument"}),'. Above, you use a generic type with specific type arguments, which is "instantiating a ',(0,s.jsx)(n.strong,{children:"generic"})," type into a ",(0,s.jsx)(n.strong,{children:"parameterized type"}),'".']}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Generic type"}),(0,s.jsxs)(n.th,{children:[(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mo,{children:"\u2192"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\rightarrow"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"\u2192"})]})})]})," Parameterized type"]})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"List<T>"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mo,{children:"\u2192"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\rightarrow"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"\u2192"})]})})]}),(0,s.jsx)(n.code,{children:" List<String>"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Generic type"}),(0,s.jsxs)(n.td,{children:[(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mo,{children:"\u2192"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\rightarrow"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"\u2192"})]})})]})," Concrete parameterized type"]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Instantiate at Value and Type level"})}),"\n",(0,s.jsxs)(n.p,{children:['They are the same at 2 levels, just different at the way of speaking. The term "instantiating" at level of values means create a ',(0,s.jsx)(n.code,{children:"new"})," object. At type level:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Value level"}),(0,s.jsx)(n.th,{children:"Type level"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:["Define methods/constructors with ",(0,s.jsx)(n.strong,{children:"value parameters"}),". E.g. ",(0,s.jsx)(n.code,{children:"int a, String b"})]}),(0,s.jsxs)(n.td,{children:["Define generic types with ",(0,s.jsx)(n.strong,{children:"type parameters"}),". E.g. ",(0,s.jsx)(n.code,{children:"<K, V>"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:["Call methods/constructors with ",(0,s.jsx)(n.strong,{children:"arguments"})," = actual values. E.g. ",(0,s.jsx)(n.code,{children:'(23, "hello")'})]}),(0,s.jsxs)(n.td,{children:["Supply ",(0,s.jsx)(n.strong,{children:"type arguments"})," = actual types. E.g. ",(0,s.jsx)(n.code,{children:"<Integer, String>"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"This is instantiate a type into an object"}),(0,s.jsx)(n.td,{children:"This is instantiate a generic type into a parameterized type"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Read again about ",(0,s.jsx)(n.a,{href:"/my-blog/docs/learn/language/java/data-types#instantiate--initialize",children:"Instantiate"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"generic-methods",children:"Generic Methods"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Motivation"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// main\nPerson ronaldo = new Person("Ronaldo", 43);\nPerson messi = new Person("Messi", 34);\nList<Person> players = new ArrayList<>();\nplayers.add(ronaldo);\nplayers.add(messi);\n// suppose we want to find youngest one\n\n// highlight-start\nfinal Person youngest = (Person) min(players, new AgeComparator());\n\npublic static Object min(List values, Comparator comparator) {\n  if(values.isEmpty()) { throw Exception("..."); }\n  Object lowestElement = values.get(0);\n  for (int i = 1; i < values.size(); i++) {\n    final Object element = values.get(i);\n    if (comparator.compare(element, lowestElement) < 0) {\n      lowestElement = element;\n    }\n  }\n  return lowestElement;\n}\n/**\nProblems:\n- We have to cast `(Person)` because we\'re not using generic\n- Compiler don\'t warn ClassCastException at compile-time -> fail at runtime. e.g.\n**/\n// -error\nfinal Person youngest = (Person) min(players, new Comparator<Integer>(){  // error in runtime\n  publbic int compare(final Integer o1, final Integer o2) { return 0; }\n});\n// highlight-end\n\n// -highlight-start\n/**\ndeclare the part `...<T> return type...` first, then you can use it in `List<T>` and `Comparator<T>`\nsomething like `public static foo(T value)` is not working\n**/\npublic static <T> T min (List<T> values, Comparator<T> comparator {\n  // replace all Object with T\n}\n// -highlight-end\n// now you can even use method reference\nList<Integer> numbers = new ArrayList<>();\nnumbers.add(1); numbers.add(2); numbers.add(3);\nSystem.out.println(min(numbers, Integer::compare));\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Usage"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Declare: place ",(0,s.jsx)(n.a,{href:"#type-parameters",children:"type parameters"})," before return."]}),"\n",(0,s.jsxs)(n.li,{children:["Call: place ",(0,s.jsx)(n.a,{href:"#type-arguments",children:"type arguments"})," before method name, or ditch it thanks to ",(0,s.jsx)(n.a,{href:"#type-inference",children:"type inference"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public record Pair<T, U>(T first, U second) {\n    /**\n      - <V, W>: type param, comes before return type\n      we need this even inside record has type params (Pair<T, U>)\n      because this is static method (cannot access instance/instantiating of their enclosing type)\n      - Pair<V, W>: return type\n      - of: method name\n     **/\n    public static <V ,W> Pair<V, W> of(V first, W second) {\n        return new Pair<>(first, second);\n    }\n\n    /**\n      this is regular non-generic methods\n      because it can access the type parameters of the enclosing record\n      unlike static, it will always be called on a particular object\n    **/\n    public Pair<T, U> withFirst(T newFirst) {\n      return Pair.of(newFirst, second);\n    }\n\n    /**\n      Read more at Functional Interface to know about BiFunction\n      BiFunction represents an arbitrary function with 2 paramters and returns a value\n      here, it can use <T, U> because it\'s an instance method\n    **/\n    public <V, W> Pair<V, W> map(BiFunction<T, U, Pair<V, W>> fn) {\n      return fn.apply(first, second);\n    }\n}\n\n// main\npublic static void main(String[] args){\n  /**\n    explicit way\n    `Pair.`: we\'re calling static method\n    <Integer, String>: type arguments\n  **/\n  var p1 = Pair.<Integer, String>of(1, "one");\n  /**\n    implicit way\n    call `of` withoud type params\n    we don\'t even need use <> like usual\n  **/\n  var p2 = Pair.of(2, "two");\n\n  // short-hand\n  var p3 = p2.map((left, right) -> Pair.of(right, left);\n  // long-hard\n  var p4 = p2.<String, Integer>map((Integer left, String right) -> Pair.<String, Integer>of(right, left));\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"bounded-type-parameters",children:"Bounded Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["Put restrictions on the types that can be used as type arguments. Use ",(0,s.jsx)(n.code,{children:"extends"})," in type parameter ",(0,s.jsx)(n.code,{children:"<>"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// note that Comparable itself a generic type\n// -highlight\npublic interface TreeNode<T extends Comparable<T>> { }\n\n// -error-start\n/**\nT in LeafNode<T> is passed into TreeNode<T>\nand compiler checks it may not be subclass of Comparable\n**/\npublic class LeafNode<T> implements TreeNode<T> { }\n// -error-end\n// -highlight\npublic class LeafNode<T extends Comparable<T>> implements TreeNode<T> { }\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"TreeNode<T extends Comparable>"})," is less safer than ",(0,s.jsx)(n.code,{children:"TreeNode<T extends Comparable<T>>"}),", it bypasses the type safety checks of the compiler (note that ",(0,s.jsx)(n.code,{children:"Comparable"})," is a generic).\nThis is also known as ",(0,s.jsx)(n.a,{href:"#raw-types",children:"raw type"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"/**\nthis means T is bounded to the Comparable interface, but without a specific type argument\n**/\nTreeNode<T extends Comparable>\n// highlight-end\n// -highlight-start\n/**\ntype T must be a subclass of Comparable with the same type argument T\nthis allows the TreeNode class to use the compareTo method defined in the Comparable interface,\nwhich can be called on objects of type T to compare them with each other.\n**/\nTreeNode<T extends Comparable<T>>\n// -highlight-end\n// highlight-start\n\n// method\nT left, T right\nleft.compareTo(right)  // works correctly\nleft.compareTo(new Object())  // if you've not told it what it's generic on, compiler won't warn, but you will get error\n"})})]}),"\n",(0,s.jsx)(n.h4,{id:"multiple-type-parameter-bounds",children:"Multiple Type Parameter Bounds"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"&"}),", ",(0,s.jsx)(n.code,{children:"|"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public interface HasId { long id(); }\npublic interface HasName { String name(); }\npublic record Product(long id, String name, String description) implements HasId, HasName { }\n\n// highlight-start\n// make this function more general by sort anything has id and name\nstatic List<String> sortByIdAndExtractNames(List<Product> list) {\n  return list.stream().sorted(Comparator.comparing(Product::id)).map(Product::name).toList();\n}\n// highlight-end\n// -highlight-start\n//     add type parameter & extends                    List<Product> -> List<T>\nstatic <T extends HasId & HasName> List<String> sortByIdAndExtractNames(List<T> list) {\n  return list.stream().sorted(Comparator.comparing(HasId::id)).map(HasName::name).toList();\n}\n// -highlight-end\n\n// main\npublic static void main(String[] args) {\n  var products = List.of(\n    new Product(100346L, "Bread", "Whole-whear loaf"),\n    new Product(100252L, "Cheese", "Gouda cheese"),\n    new Product(100123L, "Apples", "Tasty red apples"));\n  var names = sortByIdAndExtractNames(products);\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"raw-types",children:"Raw Types"}),"\n",(0,s.jsxs)(n.p,{children:["Generic type that is used without ",(0,s.jsx)(n.a,{href:"#type-arguments",children:"type arguments"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'List objects = new ArrayList();  // no <...>\nobjects.add("Hello");\nobjects.add(123);\n// -error\nString text = (String) objects.get(1);  // ClassCastException\n\nTreeNode<T extends Comparable>  // no Comparable<T>\nT left\n// -error\nleft.compareTo(new Object())   // ClassCastException\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["They are useless, and you should ",(0,s.jsx)(n.strong,{children:"avoid using raw types"}),". They only exist for backward compatibility."]})}),"\n",(0,s.jsx)(n.h3,{id:"working-with-inheritance",children:"Working with Inheritance"}),"\n",(0,s.jsxs)(n.p,{children:["Generic types are ",(0,s.jsx)(n.strong,{children:"invariant"}),'. If "a dog ',(0,s.jsx)(n.code,{children:"is-a"}),' animal", so "a list of dogs is a list of animals" is ',(0,s.jsx)(n.strong,{children:"covariance"}),". Generics have this characteristic to prevent bad things happen."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'interface Animal {}\nrecord Dog(String name) implements Animal {}\nrecord Cat(String name) implements Animal {}\n\npublic static void main(String[] args){\n  Animal animal = new Dog("Max");\n  List<Dog> dogs = new ArrayList<>(new Dog("Daisy"));\n  // -error\n  List<Animal> animals = dogs;\n  // highlight\n  animals.add(new Cat("Luna"));  // invariant avoid things like this could happen\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"wildcards",children:"Wildcards"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Motivation:"})," Read ",(0,s.jsx)(n.a,{href:"#problems",children:"this example"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Because of type-safe, generics prevents polymorphism ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mo,{children:"\u2192"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\rightarrow"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"\u2192"})]})})]})," wildcard helps us a little more flexibility but still safety."]}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsxs)(n.p,{children:["A wildcard stands for a ",(0,s.jsx)(n.strong,{children:"particular, but unknown type"}),"."]}),(0,s.jsxs)(n.p,{children:["It is ",(0,s.jsx)(n.strong,{children:"not"})," a list that contains objects of ",(0,s.jsx)(n.strong,{children:"arbitrary different types"})," (that would be ",(0,s.jsx)(n.code,{children:"List<Object>"}),")."]})]}),"\n",(0,s.jsx)(n.p,{children:"Wildcards are used to declare wildcard parameterized types:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Generic type"}),(0,s.jsx)(n.th,{children:"Parameterized type"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"List<T>"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mo,{children:"\u2192"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\rightarrow"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"\u2192"})]})})]})," Concrete parameterized type: ",(0,s.jsx)(n.code,{children:"List<String>"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"List<T>"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mo,{children:"\u2192"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\rightarrow"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"\u2192"})]})})]})," Wildcard parameterized type: ",(0,s.jsx)(n.code,{children:"List<?>"})]})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["A wildcard is a way to refer to a family of types. ",(0,s.jsx)(n.strong,{children:"Wildcard Matching"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"List<String>"}),", ",(0,s.jsx)(n.code,{children:"List<Integer>"}),", ",(0,s.jsx)(n.code,{children:"List<Map<?, ?>>"})," matches ",(0,s.jsx)(n.code,{children:"List<?>"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"List<Dog>"}),", ",(0,s.jsx)(n.code,{children:"List<Cat>"}),", ",(0,s.jsx)(n.code,{children:"List<Animal>"})," matches ",(0,s.jsx)(n.code,{children:"List<? extends Animal>"})]}),"\n"]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Substitution principle"}),": whenever we pass in argument to a method, we can pass in a subclass/implement of interface."]}),(0,s.jsxs)(n.p,{children:["Java supports ",(0,s.jsx)(n.strong,{children:"subtyping"}),", means if you have a variable of type T and S is a subtype of T, then you can assign an object of type S to the variable."]}),(0,s.jsx)(n.p,{children:"It also works with wildcard parameterized type."})]}),"\n",(0,s.jsx)(n.p,{children:"E.g."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Animal animal = new Dog("Max");  // subtyping\n// -error\nList<Animal> animals = dogs;  // generic types are invariant\n// -highlight-start\n/**\nc\xe1i n\xe0y OK v\xec subtyping\nwildcard l\xe0 vd che 1 n\u1eeda b\xean th\xec s\u1ebd kh\xf4ng bi\u1ebft ch\xednh x\xe1c l\xe0 type g\xec\n(m\u1eb7c d\xf9 nh\u1edd v\u1ebf b\xean tr\xe1i, ta bi\u1ebft \u0111\xf3 l\xe0 type Dog)\n**/\nList<? extends Animal> anmials = dogs;\n// -highlight-end\n\n/**\nList<Animal>: A List that can contain any kind of object of type Animal, it can contain both Dog and Cat objects\nList<? extends Animal>: A List of objects of a particular, but unknown type that extends Animal\n**/\n// -error-start\n/**\nch\u1ee9 wildcard kh\xf4ng ph\u1ea3i l\xe0 1 list c\u1ee7a nhi\u1ec1u lo\u1ea1i object\nvd nh\u01b0 \u1edf d\u01b0\u1edbi \u0111\xe2y c\u1ea3 2 d\xf2ng \u0111\u1ec1u error\nThe compiler expects us to supply a value that is of the capture type of the wildcard (some unknown type which extends Animal)\nbut here it\'s Dog/Cat -> error\n**/\nanimals.add(new Cat("Luna"));  // error: Cat cannot be converted to capture#1 of ? extends Animal\nanimals.add(new Dog("Max"));  // error: Dog cannot be converted to capture#1 of ? extends Animal\n// -error-end\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The capture of the wildcard is a particular ",(0,s.jsx)(n.strong,{children:"unknown"})," type that captures wildcard."]})}),"\n",(0,s.jsx)(n.h4,{id:"unbounded-wildcard",children:"Unbounded Wildcard"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"?"}),": family of all types."]}),"\n",(0,s.jsx)(n.h4,{id:"upper-bounded-wildcard",children:"Upper Bounded Wildcard"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"? extends SomeType"}),": family of types that are subtypes of the specified type, including the type itself."]}),"\n",(0,s.jsxs)(n.p,{children:["It is used to get data out of the parameter: ",(0,s.jsx)(n.strong,{children:"covariance"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"lower-bounded-wildcard",children:"Lower Bounded Wildcard"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"? super SomeType"}),": family of types that are super types of the specified type, including the type itself."]}),"\n",(0,s.jsxs)(n.p,{children:["It is used to put data into of the parameter: ",(0,s.jsx)(n.strong,{children:"contravariance"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"<T extends >"})," when you want to restrict the and refer the type elsewhere in code."]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"<? extends >"})," like a parameter on a method when you want flexibility but don't really need those type parameter."]}),"\n"]})}),"\n",(0,s.jsx)(n.h5,{id:"problems",children:"Problems"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// highlight-start\n// this requires dest and src to have exact same element type\npublic static <T> void copy(List<T> dest, List<T> src)\n// highlight-end\n\n// main\nList<Dog> dogs = List.of(new Dog("Daisy"), new Dog("Lucky"));\nList<Animal> animals = new ArrayList<>();\n// -error\ncopy(animals, dogs);  // type mismatch error\n\n// -highlight-start\n// use wildcard\n//                                  out                    in\npublic static <T> void copy(List<? super T> dest, List<? extends T> src)\n// -highlight-end\ncopy(animals, dogs);  // OK\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Use when define methods that take ",(0,s.jsx)(n.strong,{children:"parameters"})," of ",(0,s.jsx)(n.strong,{children:"parameterized types"})," (because using concrete type would cause unnecessary restrictions)."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Upper bounded wildcard for ",(0,s.jsx)(n.strong,{children:"in"})," params"]}),"\n",(0,s.jsxs)(n.li,{children:["Lower bounded wildcard for ",(0,s.jsx)(n.strong,{children:"out"})," params"]}),"\n",(0,s.jsxs)(n.li,{children:["Unbounded wildcard for param that is both ",(0,s.jsx)(n.strong,{children:"in"})," and ",(0,s.jsx)(n.strong,{children:"out"}),". E.g."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// work with list of any type & doesn't do anything with elements of the list than counting\npublic static int size(List<?> list)\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"Avoid using wildcards in the return type of a method"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"More Examples"})}),"\n",(0,s.jsx)(n.p,{children:"Wildcard in rescue:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// use generic method\npublic <T extends Person > void saveAll(List<T> persons) { }\n// use wildcard (less clumsy)\n// -error\npublic void saveAll(List<Person> persons) { }\n// -highlight\npublic void saveAll(List<? extends Person> persons) { }\n\n// main\nList<Player> persons = new ArrayList<>();\npersons.add(ronaldo);\npersons.add(messi);\n\n// we can do this without error\nsaveAll(persons);\n"})}),"\n",(0,s.jsx)(n.p,{children:"You cannot add a known things to unknown thing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'List<?> lo;\n\nList<String> ls = new ArrayList<>();\nls.add("vnd");\nls.add("10000");\n\nlo = ls;\nSystem.out.println(lo);  // [vnd, 10000]\nSystem.out.println(ls);  // [vnd, 10000]\n\nList<?> objs = new ArrayList<>();\n// -error-start\n/**\nthis is a list of objects of a specific unknown type\nyou cannot add elements to this list because the type is unknown\n**/\nobjs.add(1);\nobjs.add("vnd");\n// -error-end\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Again, wildcards allows you to pass in a list that contains objects of type Number or any superclass of Number, but it does not guarantee that the list will actually contain any Number objects.\nSo if you use ",(0,s.jsx)(n.code,{children:"<? extends>"}),", it works, because if it guarantees the list contains only objects that are convertible to Number:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public static void func(List<? super Number> nums) {\n    // -error\n    for(Number num: nums) { } // nums may include other class that's not Number convertiable\n}\n\npublic static void func(List<? extends Number> nums){\n    for (Number num: nums) { }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"type-erasure--limitations",children:"Type Erasure & Limitations"}),"\n",(0,s.jsxs)(n.p,{children:["Generics are a ",(0,s.jsx)(n.em,{children:"compile-time only"})," feature. Generic and parameterized types, type parameters and type arguments do not exist at runtime:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type parameters are replaced by Object or the leftmost bound (if they have bounds)"}),"\n",(0,s.jsx)(n.li,{children:"Type arguments are discarded"}),"\n",(0,s.jsx)(n.li,{children:"Parameterized types are replaced by raw types"}),"\n",(0,s.jsx)(n.li,{children:"Type casts are added where necessary"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Type erasure causes ",(0,s.jsx)(n.strong,{children:"limitations in generic"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cannot use primitive type as type arguments: because primitive types are not objects"}),"\n",(0,s.jsxs)(n.li,{children:["Cannot create a new instance of a type parameter: ",(0,s.jsx)(n.code,{children:"new T()"})," doesn't work"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"instaceof"})," does not work with ",(0,s.jsx)(n.strong,{children:"non-reifiable types"})," (type information is lost during type erasure, they are parameterized types with at least one concrete or bounded wildcard type argument):","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// -error\nobj instaceof List<String>  // Error\nobj instanceof List<?>  // OK\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["No ",(0,s.jsx)(n.strong,{children:"class literals"})," for parameterized types:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// -error\nClass<?> cls = List<String>.class;  // Error\nstatic class A <T extends B> { }  // this is fine\n// -error\nstatic class A <? extends B> { }\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Operations where ",(0,s.jsx)(n.em,{children:"type safety"})," cannot be guaranteed cause ",(0,s.jsx)(n.em,{children:"unchecked"})," warnings"]}),"\n",(0,s.jsxs)(n.li,{children:["Cannot ",(0,s.jsx)(n.strong,{children:"overload methods"})," with the same ",(0,s.jsx)(n.strong,{children:"method signature"})," after type erasure:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// -error-start\n// they're the same after type erasure\nvoid print(List<String> strings)  // void print(List strings)\nvoid print(List<Integer> integers)  // void print(List integers)\n// -error-end\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"heap-pollution",children:"Heap Pollution"}),"\n",(0,s.jsx)(n.p,{children:"Java's type system is not perfect. There are situations where it can be happen that a variable of a parameterized type refers to an object that is actually of a different type."}),"\n",(0,s.jsxs)(n.p,{children:["Means you can get a value in your heap that's a different type to the one that compiler thinks it should be ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mo,{children:"\u2192"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\rightarrow"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"\u2192"})]})})]})," cause runtime problems."]}),"\n",(0,s.jsx)(n.h3,{id:"working-with-array",children:"Working with Array"}),"\n",(0,s.jsx)(n.p,{children:"In Java, generics and arrays don't play nice together."}),"\n",(0,s.jsx)(n.h3,{id:"working-with-varargs",children:"Working with varargs"}),"\n",(0,s.jsxs)(n.p,{children:["Variable arguments are really just syntactic sugar for arrays ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mo,{children:"\u2192"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\rightarrow"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"\u2192"})]})})]})," not good with generics as well."]}),"\n",(0,s.jsx)(n.h2,{id:"lambda-expressions",children:"Lambda Expressions"}),"\n",(0,s.jsx)(n.h3,{id:"functional-interfaces",children:"Functional Interfaces"}),"\n",(0,s.jsxs)(n.p,{children:["A functional interface is an interface has ",(0,s.jsx)(n.strong,{children:"exactly 1 abstract method"}),". ",(0,s.jsxs)(n.em,{children:["E.g. Interface ",(0,s.jsx)(n.code,{children:"Comparator"})," is a functional interface (it only has 1 abstract ",(0,s.jsx)(n.code,{children:"compare"})," method)."]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"#lambda-expressions",children:"Lambda expression"})," & ",(0,s.jsx)(n.a,{href:"#method-references",children:"method reference"})," implements functional interface."]}),"\n",(0,s.jsx)(n.h4,{id:"standard-functional-interfaces",children:"Standard Functional Interfaces"}),"\n",(0,s.jsxs)(n.p,{children:["Package ",(0,s.jsx)(n.code,{children:"java.util.function"}),": commonly used functional interfaces."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Function<T, R>"}),": accept T, return R"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Consumer<T>"}),": accept T, no return"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Supplier<T>"}),": no args, return value (opposite ",(0,s.jsx)(n.code,{children:"Consumer"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Runnable"}),": no input, no output"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BiFunction<T, U ,R>"}),": accept T & U, return R"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BiConsumer<T, U>"}),": accept T & U, no return"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Predicate<T>"}),": accept T, return boolean"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BiPredicate<T, U>"}),": accept T & U, return boolean"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UnaryOperator<T>"}),": accept T, return T"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BinaryOperator<T>"}),": accept T & T, return T"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"lambda-expressions-1",children:"Lambda Expressions"}),"\n",(0,s.jsxs)(n.p,{children:["Lambda expression is an anonymous method. It implements a ",(0,s.jsx)(n.a,{href:"#functional-interfaces",children:"functional interface"}),".\nIt allows you to pass a block of code as an argument to a method/constructor."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@FunctionalInterface\ninterface Hello {\n    public String sayHello();\n}\n\nHello lambdaExp = () -> "Hello Lambda.";\nlambdaExp.sayHello()  // returns "Hello Lambda."\n'})}),"\n",(0,s.jsx)(n.p,{children:"There's always a functional interface involved which determines the exact type of the lambda expression. E.g:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public boolean replace(Product oldProduct, Product newProduct) {\n  List<Product> products = new ArrayList<>();\n  products.replaceAll(product -> {\n      if(product == oldProduct)\n        return newProduct;\n      else\n        return product;\n  });\n}\n/**\n`replaceAll(UnaryOperator<E> operator)`\n-> the passed-in lambda expression is actually implement an functional interface `UnaryOperator`\n**/\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You cannot assign a lambda expression to ",(0,s.jsx)(n.code,{children:"var"}),", must explicitly specify the variable type."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"/**\nnormal syntax:\naccess modifier - return type - method name - paramater list - body\n**/\npublic int compare(String first, String second) {\n  return Integer.compare(first.length(), second.length());\n}\n/**\nlambda expression syntax:\nparameter list - arrow - body\n**/\n// highlight-start\n// the types are optional\n(String first, String second) -> {\n// highlight-end\n// -highlight\n(first, second) -> Integer.compare(first.length(), second.length());\n// highlight\n}  // only return doesn't need bracket\n/**\nimplements\npublic interface Comparator<T> {\n  int compare(T o1, T o2);\n}\n**/\n"})}),"\n",(0,s.jsx)(n.h4,{id:"capturing-local-variables",children:"Capturing Local Variables"}),"\n",(0,s.jsxs)(n.p,{children:["Local variables referenced by lambda expression must be ",(0,s.jsx)(n.code,{children:"final"})," ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mo,{children:"\u2192"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\rightarrow"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"\u2192"})]})})]})," no allow modification inside or outside lambda expression."]}),"\n",(0,s.jsx)(n.p,{children:"So not always lambda expression is better:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'var names = List.of("Ronaldo", "Messi", "Neymar");\nvar count = 0;\n// -error-start\n// doesn\'t work\nnames.forEach(name -> System.out.println(++count + ": " + name));\n// -error-end\n// -highlight-start\n// works\nfor (String name : names) {\n  System.out.println(++count + ": " + name);\n}\n// -highlight-end\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Lambda expression & method reference makes it possible to functional programming style in Java: ",(0,s.jsx)(n.strong,{children:"no side effects"}),". You can but you shouldn't, it should be a pure function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'var names = List.of("A", "B", "C");\n// highlight-start\n// normal way\nvar result1 = new ArrayList<String>();\nfor(String name: names){\n  resutl1.add(name.toUpperCase());\n}\n// highlight-end\n// -error-start\n// side effect way\nvar result2 = new ArrayList<String>();\nnames.forEach(name -> result2.add(name.toUpperCase()));  // modify names\n// -error-end\n// -highlight-start\n// no side effect way\nvar result3 = names.stream().map(name -> name.toUpperCase()).toList();\n// -highlight-end\n'})}),"\n",(0,s.jsx)(n.h3,{id:"method-references",children:"Method References"}),"\n",(0,s.jsxs)(n.p,{children:["Also implements a ",(0,s.jsx)(n.a,{href:"#functional-interfaces",children:"functional interface"}),". Use ",(0,s.jsx)(n.code,{children:"::"})," operator. It can reference to:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Static methods: ",(0,s.jsx)(n.code,{children:"TypeName::staticMethodName"})]}),"\n",(0,s.jsxs)(n.li,{children:["Instance methods of particular objects: ",(0,s.jsx)(n.code,{children:"objectRef::instanceMethodName"})]}),"\n",(0,s.jsxs)(n.li,{children:["Instance methods of an arbitrary object of a particular type: ",(0,s.jsx)(n.code,{children:"TypeName::instanceMethodName"})]}),"\n",(0,s.jsxs)(n.li,{children:["Constructor: ",(0,s.jsx)(n.code,{children:"TypeName::new"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Method reference can help use handle parameter passing. Used with ",(0,s.jsx)(n.a,{href:"/my-blog/docs/learn/language/java/collections",children:"collections"}),", such as with ",(0,s.jsx)(n.code,{children:"forEach()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class Main {\n    public static void main(String[] args) {\n        var names = List.of("Sana", "Momo", "Mina");\n        // -error-start\n        // lambda expression\n        names.forEach(name -> System.out.println(name));\n        // -error-end\n        // -highlight-start\n        // method reference\n        names.forEach(System.out::println);\n        // -highlight-end\n\n        List<Shape> shapes = new ArrayList<>();\n        shapes.add(new Rectangle());\n        shapes.add(new Circle());\n        // -error-start\n        // lambda expression\n        shapes.forEach((shape) -> {\n            shape.draw();\n        });\n        // -error-end\n        // -highlight-start\n        // method reference\n        shapes.forEach(Shape::draw);\n        // -highlight-end\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"java-reflection",children:"Java Reflection"}),"\n",(0,s.jsx)(n.p,{children:"Java reflection is a feature that allows a program to inspect and modify the behavior of objects at runtime."}),"\n",(0,s.jsxs)(n.p,{children:["With reflection, a program can obtain information about ",(0,s.jsx)(n.code,{children:"Class"}),", ",(0,s.jsx)(n.code,{children:"Field"}),", ",(0,s.jsx)(n.code,{children:"Method"}),", ",(0,s.jsx)(n.code,{children:"Constructor"}),", as well as access and modify their values, invoke their methods, and create new instances of the class."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Class<?> clazz = Class.forName("MyClass");\n\n// Create a new instance of the MyClass class using reflection\nObject obj = clazz.newInstance();\n\n// Get a reference to the foo field of the MyClass class using reflection\nField field = clazz.getDeclaredField("foo");\n\n// Set the value of the foo field using reflection\nfield.setAccessible(true);\nfield.set(obj, "Hello, world!");\n\n// Invoke the bar method of the MyClass class using reflection\nMethod method = clazz.getDeclaredMethod("bar");\nmethod.setAccessible(true);\nmethod.invoke(obj);\n\n// Get all public methods of the class\nMethod[] methods = clazz.getMethods();\n'})}),"\n",(0,s.jsx)(n.h2,{id:"varargs",children:"Varargs"}),"\n",(0,s.jsx)(n.p,{children:"Varargs means variable arity arguments. These are arguments that can take a variable number of values."}),"\n",(0,s.jsx)(n.p,{children:"There's effectively an array that gets create under the hood, passed over a mythical boundary, and then thrown away afterward."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public static <T> T[] arrayOf(T ... values) {\n  return values;\n}\n// main\nInteger[] integers = arrayOf(1, 2);\nArrays.toString(integers);  // returns [1, 2]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"heap-pollution-from-parameterized-vararg-type",children:"Heap pollution from parameterized vararg type"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public static <T> T[] arrayOf(T ... values) { return values; }\npublic static <T> T[] pair(T t) { return arrayOf(t, t); }\n\n// main\nObject[] strs = pair(\"a\");\nArrays.toString(strs)  // [a, a]\n// -error-start\nInteger[] pair = pair(1);  // ClassCastException, it's look like an Integer array, but it's actually Object array\nArrays.toString(pair)\n// -error-end\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Use annotation ",(0,s.jsx)(n.code,{children:"@SafeVarargs"}),", but use it correctly."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},1151:(e,n,a)=>{a.d(n,{Z:()=>l,a:()=>i});var s=a(7294);const r={},t=s.createContext(r);function i(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);