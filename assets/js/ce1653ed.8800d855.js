"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1667],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,g=m["".concat(s,".").concat(u)]||m[u]||c[u]||i;return n?a.createElement(g,l(l({ref:t},d),{},{components:n})):a.createElement(g,l({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4870:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_label:"advanced",toc_max_heading_level:4},l="Advanced",o={unversionedId:"learn/language/java/advanced",id:"learn/language/java/advanced",title:"Advanced",description:"Annotations",source:"@site/docs/learn/language/java/12-advanced.mdx",sourceDirName:"learn/language/java",slug:"/learn/language/java/advanced",permalink:"/my-blog/docs/learn/language/java/advanced",draft:!1,editUrl:"https://github.com/huytunguyenn/my-blog/tree/main/docs/learn/language/java/12-advanced.mdx",tags:[],version:"current",sidebarPosition:12,frontMatter:{sidebar_label:"advanced",toc_max_heading_level:4},sidebar:"docs",previous:{title:"wrapper",permalink:"/my-blog/docs/learn/language/java/wrapper-classes"},next:{title:"libs",permalink:"/my-blog/docs/learn/language/java/libraries"}},s={},p=[{value:"Annotations",id:"annotations",level:2},{value:"Generics",id:"generics",level:2},{value:"Type Inference",id:"type-inference",level:4},{value:"An Example",id:"an-example",level:4},{value:"Generic Types",id:"generic-types",level:3},{value:"Type Parameters",id:"type-parameters",level:3},{value:"Type Arguments",id:"type-arguments",level:3},{value:"Generic Methods",id:"generic-methods",level:3},{value:"Bounded Type Parameters",id:"bounded-type-parameters",level:3},{value:"Raw Types",id:"raw-types",level:3},{value:"Works with Inheritance",id:"works-with-inheritance",level:3},{value:"Works with Array",id:"works-with-array",level:3},{value:"Wildcards",id:"wildcards",level:3},{value:"Unbounded",id:"unbounded",level:4},{value:"Upper bounded",id:"upper-bounded",level:4},{value:"Lower bounded",id:"lower-bounded",level:4},{value:"Type erasure",id:"type-erasure",level:3},{value:"Heap Pollution",id:"heap-pollution",level:3},{value:"Lambda Expressions",id:"lambda-expressions",level:2},{value:"Functional Interfaces",id:"functional-interfaces",level:3},{value:"Standard Functional Interfaces",id:"standard-functional-interfaces",level:4},{value:"Method References",id:"method-references",level:3},{value:"Java Reflection",id:"java-reflection",level:2},{value:"Varargs",id:"varargs",level:2}],d={toc:p};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"advanced"},"Advanced"),(0,r.kt)("h2",{id:"annotations"},"Annotations"),(0,r.kt)("p",null,"Annotations are special types that act as metadata:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"It has no direct affect on target behavior"),(0,r.kt)("li",{parentName:"ul"},"Annotation have to interpreted by things like tools (IntelliJ), execution environment (XML and JSON processors), any program"),(0,r.kt)("li",{parentName:"ul"},"Can be applied to a type or its members")),(0,r.kt)("p",null,"Common Java core platform annotations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@Override"),": indicate we override an inherited method"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@Deprecated"),": indicate which method is no longer used"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@SuppressWarnings"),": tell compiler to not generate some kind of warnings (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},'@SuppressWarnings("deprecation")'),")")),(0,r.kt)("p",null,"Others:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@FunctionalInterface"),": ",(0,r.kt)("a",{parentName:"li",href:"#functional-interfaces"},"functional interfaces"))),(0,r.kt)("h2",{id:"generics"},"Generics"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"A ",(0,r.kt)("strong",{parentName:"p"},"generic type")," is a type with ",(0,r.kt)("strong",{parentName:"p"},"type parameters"),", which is instantiated into a ",(0,r.kt)("strong",{parentName:"p"},"parameterized type")," by supplying ",(0,r.kt)("strong",{parentName:"p"},"type arguments")," to fill in its type parameters.")),(0,r.kt)("admonition",{title:"t\xf3m t\u1eaft",type:"note"},(0,r.kt)("p",{parentName:"admonition"},'N\xf4m na l\xe0 v\u1edbi type b\xecnh th\u01b0\u1eddng, m\xecnh g\u1ecdi "instantiate" l\xe0 create (instance of) new object, c\xf2n v\u1edbi generic type, create new instance of object \u0111\u01b0\u1ee3c g\u1ecdi l\xe0 "instantiating generic type into parameterized type"'),(0,r.kt)("p",{parentName:"admonition"},"D\xf9ng to\xe1n t\u1eed diamond ",(0,r.kt)("inlineCode",{parentName:"p"},"<>"),", c\u1ee9 coi n\xf3 gi\u1ed1ng nh\u01b0 ",(0,r.kt)("inlineCode",{parentName:"p"},"new"),", d\xf9ng \u0111\u1ec3 create a new object from a parameterized type")),(0,r.kt)("h4",{id:"type-inference"},"Type Inference"),(0,r.kt)("p",null,"Compiler automatically knows the type."),(0,r.kt)("h4",{id:"an-example"},"An Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public interface TreeNode<T> {\n    T getValue();\n    TreeNode<T> getLeft();\n    TreeNode<T> getRight();\n}\n\npublic class LeafNode<T> implements TreeNode<T> {\n    private final T value;\n\n    public LeafNode(T value) { this.value = value; }\n    @Override public T getValue() { return value; }\n    @Override public TreeNode<T> getLeft() { return null; }\n    @Override public TreeNode<T> getRight() { return null; }\n    @Override public String toString() { return String.format("[%s]", value); }\n}\n\npublic class InnerNode<T> implements TreeNode<T> {\n    private final TreeNode<T> left, right;\n\n    public InnerNode(TreeNode<T> left, TreeNode<T> right) {\n        this.left = left;\n        this.right = right;\n    }\n    @Override public T getValue() { return null; }\n    @Override public TreeNode<T> getLeft() { return left; }\n    @Override public TreeNode<T> getRight() { return right; }\n    @Override public String toString() { return String.format("{%s, %s}", left, right); }\n}\n// main\npublic static void main(String[] args){\n  var three = new LeafNode<Integer>(3);\n  // type inference: compiler can automatically understand as well\n  var five = new LeafNode<>(5);\n  var tree = new InnerNode<>(new LeafNode<>(2), new InnerNode<>(three, five));\n  System.out.println(tree);\n}\n')),(0,r.kt)("h3",{id:"generic-types"},"Generic Types"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"InnerNode")," is a ",(0,r.kt)("strong",{parentName:"p"},"generic type"),". Because it has ",(0,r.kt)("strong",{parentName:"p"},"type parameter")," ",(0,r.kt)("inlineCode",{parentName:"p"},"<T>")," (",(0,r.kt)("inlineCode",{parentName:"p"},"public class InnerNode<T> implements TreeNode<T>"),")."),(0,r.kt)("h3",{id:"type-parameters"},"Type Parameters"),(0,r.kt)("p",null,"A placeholder for an actual concrete type:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Usually use single capital letter for convention. ",(0,r.kt)("inlineCode",{parentName:"li"},"<T>")," stands for type, ",(0,r.kt)("inlineCode",{parentName:"li"},"<K, V>")," stands for key and value."),(0,r.kt)("li",{parentName:"ul"},"Cannot use ",(0,r.kt)("a",{parentName:"li",href:"/my-blog/docs/learn/language/java/data-types#primitive-types"},"primitive type")," as type arguments ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mo",{parentName:"mrow"},"\u2192")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\rightarrow")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.3669em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"\u2192")))))," use ",(0,r.kt)("a",{parentName:"li",href:"/my-blog/docs/learn/language/java/wrapper-classes"},"wrapper type"),"."),(0,r.kt)("li",{parentName:"ul"},"Cannot use on ",(0,r.kt)("em",{parentName:"li"},"anonymous inner classes, enums and exception classes"),".")),(0,r.kt)("p",null,"Inside the generic type, you can use type parameter as it's an actual type. E.g ",(0,r.kt)("inlineCode",{parentName:"p"},"T getValue();")," like when you use ",(0,r.kt)("inlineCode",{parentName:"p"},"Integer getValue();")),(0,r.kt)("h3",{id:"type-arguments"},"Type Arguments"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"var three = new LeafNode<Integer>(3);\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Integer")," is ",(0,r.kt)("strong",{parentName:"p"},"type argument"),'. Above, you use a generic type with specific type arguments, which is "instantiating a ',(0,r.kt)("strong",{parentName:"p"},"generic")," type into a ",(0,r.kt)("strong",{parentName:"p"},"parameterized type"),'".'),(0,r.kt)("p",null,'The term "instantiating" at level of values means create a ',(0,r.kt)("inlineCode",{parentName:"p"},"new")," object. At type level:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value level"),(0,r.kt)("th",{parentName:"tr",align:null},"Type level"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Define methods/constructors with ",(0,r.kt)("strong",{parentName:"td"},"value parameters"),". E.g. ",(0,r.kt)("inlineCode",{parentName:"td"},"int a, String b")),(0,r.kt)("td",{parentName:"tr",align:null},"Define generic types with ",(0,r.kt)("strong",{parentName:"td"},"type parameters"),". E.g. ",(0,r.kt)("inlineCode",{parentName:"td"},"<K, V>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Call methods/constructors with ",(0,r.kt)("strong",{parentName:"td"},"arguments")," = actual values. E.g. ",(0,r.kt)("inlineCode",{parentName:"td"},'(23, "hello")')),(0,r.kt)("td",{parentName:"tr",align:null},"Supply ",(0,r.kt)("strong",{parentName:"td"},"type arguments")," = actual types. E.g. ",(0,r.kt)("inlineCode",{parentName:"td"},"<Integer, String>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"This is instantiate a type into an object"),(0,r.kt)("td",{parentName:"tr",align:null},"This is instantiate a generic type into a parameterized type")))),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Read again about ",(0,r.kt)("a",{parentName:"em",href:"/my-blog/docs/learn/language/java/data-types#instantiate--initialize"},"Instantiate"),".")),(0,r.kt)("h3",{id:"generic-methods"},"Generic Methods"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public record Pair<T, U>(T first, U second) {\n    /**\n      - <V, W>: type param, comes before return type\n      we need this even inside record has type params (Pair<T, U>)\n      because this is static method (cannot access instance/instantiating of their enclosing type)\n      - Pair<V, W>: return type\n      - of: method name\n     **/\n    public static <V ,W> Pair<V, W> of(V first, W second) {\n        return new Pair<>(first, second);\n    }\n\n    /**\n      this is regular non-generic methods\n      because it can access the type parameters of the enclosing record\n      unlike static, it will always be called on a particular object\n    **/\n    public Pair<T, U> withFirst(T newFirst) {\n      return Pair.of(newFirst, second);\n    }\n\n    /**\n      BiFunction represents an arbitrary function with 2 paramters and returns a value\n      here, it can use <T, U> because it\'s an instance method\n    **/\n    public <V, W> Pair<V, W> map(BiFunction<T, U, Pair<V, W>> fn) {\n      return fn.apply(first, second);\n    }\n}\n\n// main\npublic static void main(String[] args){\n  /**\n    explicit way\n    `Pair.`: we\'re calling static method\n    <Integer, String>: type arguments\n  **/\n  var p1 = Pair.<Integer, String>of(1, "one");\n  /**\n    implicit way\n    call `of` withoud type params\n    we don\'t even need use <> like usual\n  **/\n  var p2 = Pair.of(2, "two");\n\n  // short-hand\n  var p3 = p2.map((left, right) -> Pair.of(right, left);\n  // long-hard\n  var p4 = p2.<String, Integer>map((Integer left, String right) -> Pair.<String, Integer>of(right, left));\n}\n')),(0,r.kt)("h3",{id:"bounded-type-parameters"},"Bounded Type Parameters"),(0,r.kt)("p",null,"Put restrictions on the types that can be used as type arguments."),(0,r.kt)("h3",{id:"raw-types"},"Raw Types"),(0,r.kt)("h3",{id:"works-with-inheritance"},"Works with Inheritance"),(0,r.kt)("h3",{id:"works-with-array"},"Works with Array"),(0,r.kt)("h3",{id:"wildcards"},"Wildcards"),(0,r.kt)("h4",{id:"unbounded"},"Unbounded"),(0,r.kt)("h4",{id:"upper-bounded"},"Upper bounded"),(0,r.kt)("h4",{id:"lower-bounded"},"Lower bounded"),(0,r.kt)("h3",{id:"type-erasure"},"Type erasure"),(0,r.kt)("h3",{id:"heap-pollution"},"Heap Pollution"),(0,r.kt)("h2",{id:"lambda-expressions"},"Lambda Expressions"),(0,r.kt)("p",null,"Lambda expression is an anonymous method. Allows you to pass a block of code as an argument to a method/constructor."),(0,r.kt)("p",null,"Lambda expression & method references make it possible to functional programming style in Java:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"No side effects")),(0,r.kt)("p",null,"Cannot assign a lambda expression to ",(0,r.kt)("inlineCode",{parentName:"p"},"var"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"/**\nnormal syntax:\naccess modifier - return type - method name - paramater list - body\n**/\npublic int compare(String first, String second) {\n  return Integer.compare(first.length(), second.length());\n}\n/**\nlambda expression syntax:\nparameter list - arrow - body\n**/\n// -error-start\n// the types are optional\n(String first, String second) -> {\n// -error-end\n// -highlight\n(first, second) -> Integer.compare(first.length(), second.length());\n")),(0,r.kt)("h3",{id:"functional-interfaces"},"Functional Interfaces"),(0,r.kt)("p",null,"A functional interface is an interface has exactly 1 abstract method."),(0,r.kt)("p",null,"A lambda expression implements a functional interface."),(0,r.kt)("h4",{id:"standard-functional-interfaces"},"Standard Functional Interfaces"),(0,r.kt)("p",null,"Package ",(0,r.kt)("inlineCode",{parentName:"p"},"java.util.function"),": commonly used functional interfaces."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"E.g. Interface ",(0,r.kt)("inlineCode",{parentName:"em"},"Comparator")," is a functional interface (it only has 1 abstract ",(0,r.kt)("inlineCode",{parentName:"em"},"compare")," method).")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Function")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Consumer")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Supplier")),(0,r.kt)("h3",{id:"method-references"},"Method References"),(0,r.kt)("p",null,"Also implements a functional interface. Use ",(0,r.kt)("inlineCode",{parentName:"p"},"::")," operator. It can reference to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Static methods: ",(0,r.kt)("inlineCode",{parentName:"li"},"TypeName::staticMethodName")),(0,r.kt)("li",{parentName:"ul"},"Instance methods of particular objects: ",(0,r.kt)("inlineCode",{parentName:"li"},"objectRef::instanceMethodName")),(0,r.kt)("li",{parentName:"ul"},"Instance methods of an arbitrary object of a particular type: ",(0,r.kt)("inlineCode",{parentName:"li"},"TypeName::instanceMethodName")),(0,r.kt)("li",{parentName:"ul"},"Constructor: ",(0,r.kt)("inlineCode",{parentName:"li"},"TypeName::new"))),(0,r.kt)("p",null,"Method reference can help use handle parameter passing. Used with ",(0,r.kt)("a",{parentName:"p",href:"/my-blog/docs/learn/language/java/collections"},"collections"),", such as with ",(0,r.kt)("inlineCode",{parentName:"p"},"forEach()"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class Main {\n    public static void main(String[] args) {\n        var names = List.of("Sana", "Momo", "Mina");\n        // -error-start\n        // lambda expression\n        names.forEach(name -> System.out.println(name));\n        // -error-end\n        // -highlight-start\n        // method reference\n        names.forEach(System.out::println);\n        // -highlight-end\n\n        List<Shape> shapes = new ArrayList<>();\n        shapes.add(new Rectangle());\n        shapes.add(new Circle());\n        // -error-start\n        // lambda expression\n        shapes.forEach((shape) -> {\n            shape.draw();\n        });\n        // -error-end\n        // -highlight-start\n        // method reference\n        shapes.forEach(Shape::draw);\n        // -highlight-end\n    }\n}\n')),(0,r.kt)("h2",{id:"java-reflection"},"Java Reflection"),(0,r.kt)("p",null,"Java reflection is a feature that allows a program to inspect and modify the behavior of objects at runtime."),(0,r.kt)("p",null,"With reflection, a program can obtain information about ",(0,r.kt)("inlineCode",{parentName:"p"},"Class"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Field"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Method"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Constructor"),", as well as access and modify their values, invoke their methods, and create new instances of the class."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Class<?> clazz = Class.forName("MyClass");\n\n// Create a new instance of the MyClass class using reflection\nObject obj = clazz.newInstance();\n\n// Get a reference to the foo field of the MyClass class using reflection\nField field = clazz.getDeclaredField("foo");\n\n// Set the value of the foo field using reflection\nfield.setAccessible(true);\nfield.set(obj, "Hello, world!");\n\n// Invoke the bar method of the MyClass class using reflection\nMethod method = clazz.getDeclaredMethod("bar");\nmethod.setAccessible(true);\nmethod.invoke(obj);\n\n// Get all public methods of the class\nMethod[] methods = clazz.getMethods();\n')),(0,r.kt)("h2",{id:"varargs"},"Varargs"))}c.isMDXComponent=!0}}]);